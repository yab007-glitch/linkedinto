import express from 'express';
import cors from 'cors';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { InferenceClient } from "@huggingface/inference";
import dotenv from 'dotenv';

// Load env vars from .env.local
dotenv.config({ path: '.env.local' });

// Import automation services
import { 
  fetchFeed, 
  fetchAllFeeds, 
  getAllFeeds, 
  addFeed, 
  removeFeed, 
  toggleFeed 
} from './services/rss-service.js';
import { 
  getScheduledPosts, 
  getUpcomingPosts, 
  approvePost, 
  deleteScheduledPost, 
  getQueueStats,
  toggleAutomation,
  getAutomationConfig
} from './services/post-queue-service.js';
import { 
  initializeScheduler, 
  manualGeneratePost, 
  manualRefreshFeeds 
} from './services/scheduler-service.js';
import {
  getAnalyticsSummary,
  getTopPerformingPosts,
  getTopPerformingTopics,
  getOptimalPostingTimes,
  generateAnalyticsReport,
  refreshAllAnalytics,
  getPostAnalytics
} from './services/analytics-service.js';
import {
  getScheduleConfig,
  updateScheduleConfig,
  getUpcomingScheduledTimes,
  validateCustomSchedule,
  applySchedulePreset,
  getScheduleStats,
  SCHEDULE_PRESETS
} from './services/custom-scheduling-service.js';
import {
  getAllTemplates,
  getTemplateById,
  getTemplatesByCategory,
  fillTemplate,
  selectTemplateForArticle,
  extractVariablesFromArticle,
  saveCustomTemplate,
  getAllTemplatesWithCustom,
  deleteCustomTemplate
} from './services/template-service.js';
import {
  createABTest,
  getAllABTests,
  getABTestById,
  getActiveABTests,
  getNextVariantForTest,
  assignPostToTest,
  updateTestMetrics,
  checkTestCompletion,
  getTestResults,
  stopABTest,
  deleteABTest,
  getABTestSummary
} from './services/ab-testing-service.js';

// Production middleware
import helmet from 'helmet';
import compression from 'compression';
import logger from './config/logger.js';
import { errorHandler, notFound, asyncHandler, handleUnhandledRejection, handleUncaughtException, gracefulShutdown } from './middleware/errorHandler.js';
import { requestLogger, performanceMonitor } from './middleware/requestLogger.js';
import { apiLimiter, generationLimiter, feedLimiter } from './middleware/rateLimiter.js';
import { sanitize } from './middleware/validation.js';
import { healthCheck, liveness, readiness, metrics } from './middleware/healthCheck.js';

// Handle uncaught exceptions and unhandled rejections
handleUncaughtException();
handleUnhandledRejection();

const app = express();
const PORT = process.env.PORT || 3001;
const NODE_ENV = process.env.NODE_ENV || 'development';

// Security middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  crossOriginEmbedderPolicy: false,
}));

// Compression middleware
app.use(compression());

// CORS middleware
app.use(cors({
  origin: process.env.CORS_ORIGIN || '*',
  credentials: true,
}));

// Body parser middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Request logging
app.use(requestLogger);
app.use(performanceMonitor);

// Input sanitization
app.use(sanitize);

// Health check endpoints (no rate limiting)
app.get('/health', healthCheck);
app.get('/health/live', liveness);
app.get('/health/ready', readiness);
app.get('/metrics', metrics);

// Apply rate limiting to API routes
app.use('/api', apiLimiter);

// Initialize HF Client
const HF_TOKEN = process.env.VITE_HUGGINGFACE_API_KEY || process.env.HUGGINGFACE_API_KEY || process.env.HF_TOKEN;

if (!HF_TOKEN) {
    console.warn("Warning: HF_TOKEN/HUGGINGFACE_API_KEY not found in environment variables.");
}

const hf = new InferenceClient(HF_TOKEN);

// Database simulation (simple JSON file)
const DB_FILE = 'db.json';

const getDb = async () => {
  try {
    const data = await fs.readFile(DB_FILE, 'utf-8');
    return JSON.parse(data);
  } catch (error) {
    // If file doesn't exist, return default structure
    return { posts: [] };
  }
};

const saveDb = async (data) => {
  await fs.writeFile(DB_FILE, JSON.stringify(data, null, 2));
};

// --- API Routes ---

// 1. History Endpoints
app.get('/api/history', async (req, res) => {
  try {
    const db = await getDb();
    // Sort by timestamp desc
    const sorted = db.posts.sort((a, b) => b.timestamp - a.timestamp);
    res.json(sorted);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch history' });
  }
});

app.post('/api/history', async (req, res) => {
  try {
    const newPost = req.body;
    const db = await getDb();
    db.posts.push(newPost);
    await saveDb(db);
    res.status(201).json(newPost);
  } catch (error) {
    res.status(500).json({ error: 'Failed to save post' });
  }
});

// 2. Generation Endpoints (Backend Proxy)
app.post('/api/generate', async (req, res) => {
    try {
        const { model, messages, ...params } = req.body;
        
        console.log("Generating with model:", model || "Qwen/Qwen2.5-7B-Instruct");

        const chatCompletion = await hf.chatCompletion({
            model: model || "Qwen/Qwen2.5-7B-Instruct",
            messages: messages,
            ...params
        });

        if (chatCompletion.choices && chatCompletion.choices.length > 0) {
             res.json({ content: chatCompletion.choices[0].message.content });
        } else {
             throw new Error("No content generated");
        }

    } catch (error) {
        console.error("Generation Error:", error);
        res.status(500).json({ error: error.message || "Failed to generate content" });
    }
});

// 3. LinkedIn Proxy Endpoints
app.get('/api/linkedin/me', async (req, res) => {
  const authHeader = req.headers.authorization;
  if (!authHeader) return res.status(401).json({ error: 'No token provided' });

  try {
    const response = await fetch("https://api.linkedin.com/v2/userinfo", {
      headers: { 'Authorization': authHeader }
    });

    const data = await response.json();
    res.status(response.status).json(data);
  } catch (error) {
    console.error("LinkedIn Proxy Error:", error);
    res.status(500).json({ error: 'Proxy error' });
  }
});

app.post('/api/linkedin/post', async (req, res) => {
  const authHeader = req.headers.authorization;
  if (!authHeader) return res.status(401).json({ error: 'No token provided' });

  try {
    const response = await fetch("https://api.linkedin.com/v2/ugcPosts", {
      method: 'POST',
      headers: {
        'Authorization': authHeader,
        'Content-Type': 'application/json',
        'X-Restli-Protocol-Version': '2.0.0'
      },
      body: JSON.stringify(req.body)
    });

    const data = await response.text();
    
    // We try to parse JSON, if not return text
    let json;
    try {
        json = JSON.parse(data);
    } catch(e) {
        json = { message: data };
    }

    res.status(response.status).json(json);
  } catch (error) {
    console.error("LinkedIn Proxy Error:", error);
    res.status(500).json({ error: 'Proxy error' });
  }
});

// 4. RSS Feed Automation Endpoints

// Get all RSS feeds
app.get('/api/feeds', async (req, res) => {
  try {
    const feeds = await getAllFeeds();
    res.json(feeds);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch feeds' });
  }
});

// Add a new feed
app.post('/api/feeds', async (req, res) => {
  try {
    const newFeed = await addFeed(req.body);
    res.status(201).json(newFeed);
  } catch (error) {
    res.status(500).json({ error: 'Failed to add feed' });
  }
});

// Delete a feed
app.delete('/api/feeds/:id', async (req, res) => {
  try {
    await removeFeed(req.params.id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Failed to remove feed' });
  }
});

// Toggle feed enabled status
app.patch('/api/feeds/:id/toggle', async (req, res) => {
  try {
    await toggleFeed(req.params.id, req.body.enabled);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Failed to toggle feed' });
  }
});

// Manually refresh a specific feed
app.post('/api/feeds/:id/refresh', async (req, res) => {
  try {
    const result = await fetchFeed(req.params.id);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: 'Failed to refresh feed' });
  }
});

// Manually refresh all feeds
app.post('/api/feeds/refresh-all', async (req, res) => {
  try {
    const results = await manualRefreshFeeds();
    res.json(results);
  } catch (error) {
    res.status(500).json({ error: 'Failed to refresh feeds' });
  }
});

// Get all scheduled posts
app.get('/api/scheduled-posts', async (req, res) => {
  try {
    const posts = await getScheduledPosts();
    res.json(posts);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch scheduled posts' });
  }
});

// Get upcoming posts
app.get('/api/scheduled-posts/upcoming', async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 10;
    const posts = await getUpcomingPosts(limit);
    res.json(posts);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch upcoming posts' });
  }
});

// Approve a post
app.post('/api/scheduled-posts/:id/approve', async (req, res) => {
  try {
    const post = await approvePost(req.params.id);
    res.json(post);
  } catch (error) {
    res.status(500).json({ error: 'Failed to approve post' });
  }
});

// Delete a scheduled post
app.delete('/api/scheduled-posts/:id', async (req, res) => {
  try {
    await deleteScheduledPost(req.params.id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Failed to delete post' });
  }
});

// Get queue statistics
app.get('/api/automation/stats', async (req, res) => {
  try {
    const stats = await getQueueStats();
    res.json(stats);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch stats' });
  }
});

// Get automation config
app.get('/api/automation/config', async (req, res) => {
  try {
    const config = await getAutomationConfig();
    res.json(config);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch config' });
  }
});

// Toggle automation
app.post('/api/automation/toggle', async (req, res) => {
  try {
    const config = await toggleAutomation(req.body.enabled);
    res.json(config);
  } catch (error) {
    res.status(500).json({ error: 'Failed to toggle automation' });
  }
});

// Manually trigger post generation
app.post('/api/automation/generate-now', async (req, res) => {
  try {
    await manualGeneratePost();
    res.json({ success: true, message: 'Post generation triggered' });
  } catch (error) {
    res.status(500).json({ error: 'Failed to generate post' });
  }
});

// 5. Analytics Endpoints

// Get analytics summary
app.get('/api/analytics/summary', async (req, res) => {
  try {
    const days = parseInt(req.query.days) || 30;
    const summary = await getAnalyticsSummary(days);
    res.json(summary);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch analytics summary' });
  }
});

// Get top performing posts
app.get('/api/analytics/top-posts', async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 10;
    const metric = req.query.metric || 'engagementRate';
    const topPosts = await getTopPerformingPosts(limit, metric);
    res.json(topPosts);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch top posts' });
  }
});

// Get top performing topics
app.get('/api/analytics/top-topics', async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 5;
    const topics = await getTopPerformingTopics(limit);
    res.json(topics);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch top topics' });
  }
});

// Get optimal posting times
app.get('/api/analytics/optimal-times', async (req, res) => {
  try {
    const optimalTimes = await getOptimalPostingTimes();
    res.json(optimalTimes);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch optimal times' });
  }
});

// Get full analytics report
app.get('/api/analytics/report', async (req, res) => {
  try {
    const days = parseInt(req.query.days) || 30;
    const report = await generateAnalyticsReport(days);
    res.json(report);
  } catch (error) {
    res.status(500).json({ error: 'Failed to generate report' });
  }
});

// Refresh all analytics
app.post('/api/analytics/refresh', async (req, res) => {
  try {
    const result = await refreshAllAnalytics();
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: 'Failed to refresh analytics' });
  }
});

// Get analytics for specific post
app.get('/api/analytics/post/:id', async (req, res) => {
  try {
    const analytics = await getPostAnalytics(req.params.id);
    if (!analytics) {
      return res.status(404).json({ error: 'Analytics not found' });
    }
    res.json(analytics);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch post analytics' });
  }
});

// 6. Custom Scheduling Endpoints

// Get schedule configuration
app.get('/api/schedule/config', async (req, res) => {
  try {
    const config = await getScheduleConfig();
    res.json(config);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch schedule config' });
  }
});

// Update schedule configuration
app.put('/api/schedule/config', async (req, res) => {
  try {
    const config = await updateScheduleConfig(req.body);
    res.json(config);
  } catch (error) {
    res.status(500).json({ error: 'Failed to update schedule config' });
  }
});

// Get upcoming scheduled times
app.get('/api/schedule/upcoming', async (req, res) => {
  try {
    const count = parseInt(req.query.count) || 10;
    const times = await getUpcomingScheduledTimes(count);
    res.json(times);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch upcoming times' });
  }
});

// Validate custom schedule
app.post('/api/schedule/validate', async (req, res) => {
  try {
    const validation = validateCustomSchedule(req.body.schedule);
    res.json(validation);
  } catch (error) {
    res.status(500).json({ error: 'Failed to validate schedule' });
  }
});

// Get schedule presets
app.get('/api/schedule/presets', async (req, res) => {
  try {
    res.json(SCHEDULE_PRESETS);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch presets' });
  }
});

// 7. Template Endpoints

// Get all templates
app.get('/api/templates', async (req, res) => {
  try {
    const includeCustom = req.query.includeCustom === 'true';
    const templates = includeCustom 
      ? await getAllTemplatesWithCustom()
      : getAllTemplates();
    res.json(templates);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch templates' });
  }
});

// Get template by ID
app.get('/api/templates/:id', async (req, res) => {
  try {
    const template = getTemplateById(req.params.id);
    if (!template) {
      return res.status(404).json({ error: 'Template not found' });
    }
    res.json(template);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch template' });
  }
});

// Get templates by category
app.get('/api/templates/category/:category', async (req, res) => {
  try {
    const templates = getTemplatesByCategory(req.params.category);
    res.json(templates);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch templates' });
  }
});

// Fill template with variables
app.post('/api/templates/:id/fill', async (req, res) => {
  try {
    const content = fillTemplate(req.params.id, req.body.variables);
    res.json({ content });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Save custom template
app.post('/api/templates/custom', async (req, res) => {
  try {
    const template = await saveCustomTemplate(req.body);
    res.status(201).json(template);
  } catch (error) {
    res.status(500).json({ error: 'Failed to save template' });
  }
});

// Delete custom template
app.delete('/api/templates/custom/:id', async (req, res) => {
  try {
    await deleteCustomTemplate(req.params.id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Failed to delete template' });
  }
});

// 8. A/B Testing Endpoints

// Get all A/B tests
app.get('/api/ab-tests', async (req, res) => {
  try {
    const tests = await getAllABTests();
    res.json(tests);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch A/B tests' });
  }
});

// Get A/B test by ID
app.get('/api/ab-tests/:id', async (req, res) => {
  try {
    const test = await getABTestById(req.params.id);
    if (!test) {
      return res.status(404).json({ error: 'Test not found' });
    }
    res.json(test);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch test' });
  }
});

// Get active A/B tests
app.get('/api/ab-tests/status/active', async (req, res) => {
  try {
    const tests = await getActiveABTests();
    res.json(tests);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch active tests' });
  }
});

// Create A/B test
app.post('/api/ab-tests', async (req, res) => {
  try {
    const test = await createABTest(req.body);
    res.status(201).json(test);
  } catch (error) {
    res.status(500).json({ error: 'Failed to create test' });
  }
});

// Get test results
app.get('/api/ab-tests/:id/results', async (req, res) => {
  try {
    const results = await getTestResults(req.params.id);
    res.json(results);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch results' });
  }
});

// Update test metrics
app.post('/api/ab-tests/:id/update-metrics', async (req, res) => {
  try {
    const test = await updateTestMetrics(req.params.id);
    res.json(test);
  } catch (error) {
    res.status(500).json({ error: 'Failed to update metrics' });
  }
});

// Stop A/B test
app.post('/api/ab-tests/:id/stop', async (req, res) => {
  try {
    const test = await stopABTest(req.params.id);
    res.json(test);
  } catch (error) {
    res.status(500).json({ error: 'Failed to stop test' });
  }
});

// Delete A/B test
app.delete('/api/ab-tests/:id', async (req, res) => {
  try {
    await deleteABTest(req.params.id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Failed to delete test' });
  }
});

// Get A/B test summary
app.get('/api/ab-tests-summary', async (req, res) => {
  try {
    const summary = await getABTestSummary();
    res.json(summary);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch summary' });
  }
});

// Apply schedule preset
app.post('/api/schedule/preset/:name', async (req, res) => {
  try {
    const config = await applySchedulePreset(req.params.name);
    res.json(config);
  } catch (error) {
    res.status(500).json({ error: 'Failed to apply preset' });
  }
});

// Get schedule statistics
app.get('/api/schedule/stats', async (req, res) => {
  try {
    const stats = await getScheduleStats();
    res.json(stats);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch schedule stats' });
  }
});

// Initialize scheduler
console.log('\nðŸš€ Starting automation services...');
initializeScheduler();

app.listen(PORT, () => {
  console.log(`Backend server running at http://localhost:${PORT}`);
});

// 404 handler - must be after all routes
app.use(notFound);

// Error handler - must be last
app.use(errorHandler);
